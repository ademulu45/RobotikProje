:imagesdir: Resimler
# RobotikProje

Adem ULU-120201019

Gökçe EMİRBUYURAN-110201112

Husein SKRİJELJ-120201113

== SLAM6D - Simultaneous Localization and Mapping with 6 DoF

==== Proje Hakkında Açıklama
Bu proje, 3D nokta bulutlarını ortak bir koordinat sistemine kaydetmenin yanı sıra sahneyi görüntülemek için bir görüntüleyiciden oluşan bir yazılımdan oluşmaktadır. Kayıt için, genel olarak tutarlı bir sahne yaratmayı amaçlayan küresel gevşeme yöntemlerinin yanı sıra farklı ICP en aza indirme algoritmaları da seçilebilir. Nokta bulutları için çeşitli formatlar desteklenmekte, yeni formatlar kolayca uygulanabilmektedir.

Projemiz ile ilgili örnek resimler:

image::indoor.png[indoor,480,320,align="center"]

image::outdoor.png[outdoor,480,320,align="center"]


Kullandığımız işletim sistemi: Ubuntu 14.04 İndigo(Sanal Makina)

Proje kaynak kodlarını elde etmek için tüm işletim sistemlerine uygun olan cmake kurulumunu yaptık.
Ubuntu cmake kurulum komutu:
[source,java]
----
sudo apt-get install cmake
----
Kurulum sonrası terminale aşağıdaki komut yazılarak kaynak kodları elde edildi.
[source,java]
----
svn co https://svn.openslam.org/data/svn/slam6d
----
Kaynak kodları indirdikten sonra içerisindeki *readme.txt* ve *install.txt* dosyalarını inceledik.
Kodları çalıştırmak için *install.txt* dosyası içeriğini takip ettik.

Aşağıda bu adımlara ve bu adımları uygularken elde ettiğimiz görüntülere yer vereceğiz. İlk adımlardaki işlemler ön hazırlık adımları olduğu için ekran görüntülerini 8. 9. ve 10. adımlarda koyduk.

*1.Adım:*
[source,java]
----
echo deb http://archive.ubuntu.com/ubuntu trusty main universe | sudo tee -a /etc/apt/sources.list > /dev/null
----
*2.Adım:* Güncelleme işlemi.
[source,java]
----
sudo apt-get update
----
*3.Adım:*
----
sudo apt-get install --no-install-recommends equivs subversion
----
*4.Adım:* Klasör değiştirme işlemi.
[source,java]
----
cd slam6d-code
----
*5.Adım:*
[source,java]
----
equivs-build doc/equivs/control
----
*6.Adım:*
[source,java]
----
sudo dpkg -i 3dtk-build-deps_1.0_all.deb
----
*7.Adım:*
[source,java]
----
sudo apt-get -f install --no-install-recommends
----
*8.Adım:*
[source,java]
----
make
----
Bu işlem sonucu elde ettiğimiz sonuç çıktısı aşağıdadır.

image::adim8.png[adim8,480,320,align="center"]

*9.Adım:*
[source,java]
----
bin/slam6D dat
----
Bu işlem sonucu elde ettiğimiz sonuç çıktısı aşağıdadır.

image::adim9.png[adim9,480,320,align="center"]

*10.Adım:*
[source,java]
----
bin/show dat
----
Bu işlem sonucu elde ettiğimiz sonuç çıktısı aşağıdadır.

image::soncikti.png[soncikti,800,480,align="center"]

==== Kaynak Klasör İçindeki Dokümanların İncelenmesi


==== Baaska veri seti ile calistirmasi

Bu veri seti http://kos.informatik.uni-osnabrueck.de/3Dscans/ Hannover1 adli veri seti kullandik,çunku boyut olarak idealdi. Diğer veri setiler büyük boyutla olduğu için test edemedik. Veri indirtikren sonra, verinin lokasiyoun aldiktan sonra 
*Bu komutu calismamiz lazim, veriler test etmek icin*[source,java]
----
/slam6d-code$ bin/show -s 1 -e65 /home/huse/Desktop/hannover1
----
komutu ile :

image::Hanover_dataSet1.PNG[Hanover_dataSet1,480,80,align="center"]

image::Hanover_dataSet2.PNG[Hanover_dataSet2,480,320,align="center"]

image::Hanover_dataSet.PNG[Hanover_dataSet,800,480,align="center"]

== 3. Algoritmanın Kod İçerisinde Bulunması

Bu proje, 3D nokta bulutlarını ortak bir koordinat sistemine kaydetmenin yanı sıra sahneyi görüntülemek için bir görüntüleyiciden oluşan bir yazılımdan oluşmaktadır. Kayıt için, genel olarak tutarlı bir sahne yaratmayı amaçlayan küresel gevşeme yöntemlerinin yanı sıra farklı ICP en aza indirme algoritmaları da seçilebilir. Nokta bulutları için çeşitli formatlar desteklenmekte, yeni formatlar kolayca uygulanabilmektedir.

=== 3.1. Değişkenlerin Koddaki Karşılıkları


[width="100%",options="header,footer"]
|====================
|(R, t)  | double
alignxf[16] |  Dönüşüm
Matrisi
|m~i~,d~i~  |class
PtPair  |  Nokta
çifti
| c~m~,c~d~ |double
cm[3], cd[3]  |  Ağırlık
Merkezleri
| m~i~',d~i~' | double**
m, d |  Merkezleştirilmiş
Nokta Çiftleri
| H, U ,
Λ, V | Matrix |  SVD Matrisleri
| R | double
transMat[16] |  Matrix olarak pozisyon<o:p></o:p>
| (x~n~, y~n~, z~n~) | double
rPos[3] |  n. ‘inci
3D Taramanın Pozisyonu
* | (θ~x,n~, θ~x,n~, θ~x,n~)| double
rPostheta[3] |  n. ‘inci 3D Taramanın Rotasyonu
|====================

=== 3.2. Kodun İncelenmesi

Projenin main fonksiyonu *src/slam6d* dizinindeki *slam6D.cc* dosyasının içerisinde yer almaktadır.

==== Dönüşüm ve Çevrimin Hesaplanması

image::k1.png[indoor,480,160,align="center"]

image::k2.png[indoor,320,160,align="center"]

(icp6Dquat.cc)

[source, C++]
----

for (int i = 0; i < openmp_num_threads; i++) {
    s += sum[i];
    pairs_size += n[i];
    cm[0] += n[i] * centroid_m[i][0];
    cm[1] += n[i] * centroid_m[i][1];
    cm[2] += n[i] * centroid_m[i][2];
    cd[0] += n[i] * centroid_d[i][0];
    cd[1] += n[i] * centroid_d[i][1];
    cd[2] += n[i] * centroid_d[i][2];
  }
  cm[0] /= pairs_size;
  cm[1] /= pairs_size;
  cm[2] /= pairs_size;
  cd[0] /= pairs_size;
  cd[1] /= pairs_size;
  cd[2] /= pairs_size;

// calculate the cross covariance matrix
  // formula (5)
  for (int i = 0; i < openmp_num_threads; i++) {
    for(int j = 0; j < 3; j++){
      for(int k = 0; k < 3; k++){
        S[j][k] += Si[i][k*3+j]
          + n[i] * ((centroid_d[i][j] - cd[j]) * (centroid_m[i][k] - cm[k])) ;
      }
    }
  }

----

image::k3.png[indoor,240,180,align="center"]

(icp6Dsvd.cc)

[source, C++]
----

Matrix U(3,3);
  DiagonalMatrix Lamda(3);
  Matrix V(3,3);
  // Make SVD
  SVD(H, Lamda, U, V);

  // Get rotation
  R = V*(U.t());

----

image::k4.png[indoor,240,160,align="center"]

[source, C++]
----

// calculate the rotation matrix
  double m[3][3]; // rot matrix
  quaternion2matrix(q, m);

  M4identity(alignfx);

  alignfx[0] = m[0][0];
  alignfx[1] = m[1][0];
  alignfx[2] = m[2][0];
  alignfx[3] = 0.0;
  alignfx[4] = m[0][1];
  alignfx[5] = m[1][1];
  alignfx[6] = m[2][1];
  alignfx[7] = 0.0;
  alignfx[8] = m[0][2];
  alignfx[9] = m[1][2];
  alignfx[10] = m[2][2];
  alignfx[11] = 0.0;

  // calculate the translation vector,
  alignfx[12] = cm[0] - m[0][0]*cd[0] - m[0][1]*cd[1] - m[0][2]*cd[2];
  alignfx[13] = cm[1] - m[1][0]*cd[0] - m[1][1]*cd[1] - m[1][2]*cd[2];
  alignfx[14] = cm[2] - m[2][0]*cd[0] - m[2][1]*cd[1] - m[2][2]*cd[2];

----

==== ICP tabanlı 6D Slam 


image::k5.png[indoor,480,240,align="center"]

(elch6Deuler.cc)

[source, C++]
----

double delta[6];
  delta[0] = allScans[last]->get_rPos()[0];
  delta[1] = allScans[last]->get_rPos()[1];
  delta[2] = allScans[last]->get_rPos()[2];
  delta[3] = allScans[last]->get_rPosTheta()[0];
  delta[4] = allScans[last]->get_rPosTheta()[1];
  delta[5] = allScans[last]->get_rPosTheta()[2];

  my_icp6D->match(start, end);

  delete start;
  delete end;
  
  delta[0] = allScans[last]->get_rPos()[0] - delta[0];
  delta[1] = allScans[last]->get_rPos()[1] - delta[1];
  delta[2] = allScans[last]->get_rPos()[2] - delta[2];
  delta[3] = allScans[last]->get_rPosTheta()[0] - delta[3];
  delta[4] = allScans[last]->get_rPosTheta()[1] - delta[4];
  delta[5] = allScans[last]->get_rPosTheta()[2] - delta[5];

  if(!quiet) {
    cout << "Delta: " << delta[0] << " " << delta[1] << " " << delta[2]
         << " " << delta[3] << " " << delta[4] << " " << delta[5] << endl;
  }

  double rPos[3], rPosTheta[3];
  for(int i = 1; i < n; i++) {
    rPos[0] = allScans[i]->get_rPos()[0] +
      delta[0] * (weights[0][i] - weights[0][0]);
    rPos[1] = allScans[i]->get_rPos()[1] +
      delta[1] * (weights[1][i] - weights[1][0]);
    rPos[2] = allScans[i]->get_rPos()[2] +
      delta[2] * (weights[2][i] - weights[2][0]);
    rPosTheta[0] = allScans[i]->get_rPosTheta()[0] +
      delta[3] * (weights[3][i] - weights[3][0]);
    rPosTheta[1] = allScans[i]->get_rPosTheta()[1] +
      delta[4] * (weights[4][i] - weights[4][0]);
    rPosTheta[2] = allScans[i]->get_rPosTheta()[2] +
      delta[5] * (weights[5][i] - weights[5][0]);

    allScans[i]->transformToEuler(rPos, rPosTheta,
                                  Scan::ELCH, i == n-1 ? 2 : 1);
  }

----

