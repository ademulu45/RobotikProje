:imagesdir: Resimler
# RobotikProje

Adem ULU-120201019

Gökçe EMİRBUYURAN-110201112

Husein SKRİJELJ-120201113

== SLAM6D - Simultaneous Localization and Mapping with 6 DoF

==== Proje Hakkında Açıklama
Bu proje, 3D nokta bulutlarını ortak bir koordinat sistemine kaydetmenin yanı sıra sahneyi görüntülemek için bir görüntüleyiciden oluşan bir yazılımdan oluşmaktadır. Kayıt için, genel olarak tutarlı bir sahne yaratmayı amaçlayan küresel gevşeme yöntemlerinin yanı sıra farklı ICP en aza indirme algoritmaları da seçilebilir. Nokta bulutları için çeşitli formatlar desteklenmekte, yeni formatlar kolayca uygulanabilmektedir.

Projemiz ile ilgili örnek resimler:

image::indoor.png[indoor,480,320,align="center"]

image::outdoor.png[outdoor,480,320,align="center"]


Kullandığımız işletim sistemi: Ubuntu 14.04 İndigo(Sanal Makina)

Proje kaynak kodlarını elde etmek için tüm işletim sistemlerine uygun olan cmake kurulumunu yaptık.
Ubuntu cmake kurulum komutu:
[source,java]
----
sudo apt-get install cmake
----
Kurulum sonrası terminale aşağıdaki komut yazılarak kaynak kodları elde edildi.
[source,java]
----
svn co https://svn.openslam.org/data/svn/slam6d
----
Kaynak kodları indirdikten sonra içerisindeki *readme.txt* ve *install.txt* dosyalarını inceledik.
Kodları çalıştırmak için *install.txt* dosyası içeriğini takip ettik.

Aşağıda bu adımlara ve bu adımları uygularken elde ettiğimiz görüntülere yer vereceğiz. İlk adımlardaki işlemler ön hazırlık adımları olduğu için ekran görüntülerini 8. 9. ve 10. adımlarda koyduk.

*1.Adım:*
[source,java]
----
echo deb http://archive.ubuntu.com/ubuntu trusty main universe | sudo tee -a /etc/apt/sources.list > /dev/null
----
*2.Adım:* Güncelleme işlemi.
[source,java]
----
sudo apt-get update
----
*3.Adım:*
----
sudo apt-get install --no-install-recommends equivs subversion
----
*4.Adım:* Klasör değiştirme işlemi.
[source,java]
----
cd slam6d-code
----
*5.Adım:*
[source,java]
----
equivs-build doc/equivs/control
----
*6.Adım:*
[source,java]
----
sudo dpkg -i 3dtk-build-deps_1.0_all.deb
----
*7.Adım:*
[source,java]
----
sudo apt-get -f install --no-install-recommends
----
*8.Adım:*
[source,java]
----
make
----
Bu işlem sonucu elde ettiğimiz sonuç çıktısı aşağıdadır.

image::adim8.png[adim8,480,320,align="center"]

*9.Adım:*
[source,java]
----
bin/slam6D dat
----
Bu işlem sonucu elde ettiğimiz sonuç çıktısı aşağıdadır.

image::adim9.png[adim9,480,320,align="center"]

*10.Adım:*
[source,java]
----
bin/show dat
----
Bu işlem sonucu elde ettiğimiz sonuç çıktısı aşağıdadır.

image::soncikti.png[soncikti,800,480,align="center"]

==== Kaynak Klasör İçindeki Dokümanların İncelenmesi
== PROJECTİON BASED 3D LASER SCANNER
== Kurulum ve Hedef
== Kurulum
Video,bir lazer çizgisinin nesnenin üzerinde hareket ettiği, köşede yer alıyor.
90 derece açı bulunuyor
Her iki duvarda dama tahtaları bulunuyor
Arkaplanda değişiklik yok
Kamera otomatik ayarlanmıyor

== HEDEF
Nesnenin 3D modellenmesi
3D nokta bulutu(X,Y,Z)
Nokta renkleri(R,G,B)

image::3D-laser-scanner.png[adim9,480,320,align="center"]

*ADIM 1:* Laser Çizgileri Algılama
Her çerçeve için lazer çizgisi olmayan çerçeve farkı hesaplanır.
Kırmızı pikselleri bulunur ve vurgulanır.

2'den daha az kırmızı komşusu olan tüm kırmızı pikselleri çıkarıp gürültünün bir kısmından kurtulun
Hatları algılamak için Hough dönüşümünü kullanılır ve yeşil renkte çizilir

image::1-3D-laser-scanner.png[adim9,480,320,align="center"]

*ADIM 2:* 3D Object Points
Nesneye ait olan noktaların pikselleri göz önüne alındığında, 3D nokta bulutu almak istiyoruz.

Önce kamerayı kalibre etmeniz gerekiyor - İçsel ve dışsal parametreleri bulun.

Lazer çizgilerinden doğrusal olmayan 3 noktayı alarak lazer düzlemini bulunuz.

Kameradan ve lazer düzleminden başlayarak ışınların kesiştiği noktalar olarak 3D koordinatları bulun.

Nokta bulutunu görüntülemek için görüntüleme programı kullanılır.

*ADIM 3:*

== Using SLAM6D
Teorik olarak slam6D programı, birkaç nokta bulutunu eşleştirebilir ve bunları aynı referans çerçevesine yerleştirebilir.
Pratikte, birden fazla veri seti kullanırken eşleştirme işlemi çok iyi sonuç vermedi.
Olası nedeni:

.pose dosyalarının manuel olarak ayarlanması hatalara açıktır.
Kullanılmış kümeler daha yüksek örtüşme (daha küçük dönme açısı) gerektirebilir.

image::2-3D-laser-scanner.png[adim9,480,320,align="center"]

==== Baska veri seti ile calistirmasi

Bu veri seti http://kos.informatik.uni-osnabrueck.de/3Dscans/ Hannover1 adli veri seti kullandik,çunku boyut olarak idealdi. Diğer veri setiler büyük boyutla olduğu için test edemedik. Veri indirtikren sonra, verinin lokasiyoun aldiktan sonra 
*Bu komutu calismamiz lazim, veriler test etmek icin*[source,java]
----
/slam6d-code$ bin/show -s 1 -e65 /home/huse/Desktop/hannover1
----
komutu ile :

image::Hanover_dataSet1.PNG[Hanover_dataSet1,480,80,align="center"]

Aşağıdaki veri seti üzerinde işlem yapmaya çalıştık. Ancak veri seti boyutu 8.8 gb gibi büyük bir değer olduğu için sanal makine için sıkıntı oluşabileceğinden dolayı kullanamadık.

image::Hanover_dataSet2.PNG[Hanover_dataSet2,480,320,align="center"]

Küçük boyuta sahip hannover veri seti üzerinde deneme yapabildik. İşlemler sonucunda elde ettiğimiz görüntü aşağıda yer almaktadır.


image::Hanover_dataSet.PNG[Hanover_dataSet,800,480,align="center"]

== 3. Algoritmanın Kod İçerisinde Bulunması

Bu proje, 3D nokta bulutlarını ortak bir koordinat sistemine kaydetmenin yanı sıra sahneyi görüntülemek için bir görüntüleyiciden oluşan bir yazılımdan oluşmaktadır. Kayıt için, genel olarak tutarlı bir sahne yaratmayı amaçlayan küresel gevşeme yöntemlerinin yanı sıra farklı ICP en aza indirme algoritmaları da seçilebilir. Nokta bulutları için çeşitli formatlar desteklenmekte, yeni formatlar kolayca uygulanabilmektedir.

=== 3.1. Değişkenlerin Koddaki Karşılıkları


[width="100%",options="header,footer"]
|====================
|(R, t)  | double
alignxf[16] |  Dönüşüm
Matrisi
|m~i~,d~i~  |class
PtPair  |  Nokta
çifti
| c~m~,c~d~ |double
cm[3], cd[3]  |  Ağırlık
Merkezleri
| m~i~',d~i~' | double**
m, d |  Merkezleştirilmiş
Nokta Çiftleri
| H, U ,
Λ, V | Matrix |  SVD Matrisleri
| R | double
transMat[16] |  Matrix olarak pozisyon<o:p></o:p>
| (x~n~, y~n~, z~n~) | double
rPos[3] |  n. ‘inci
3D Taramanın Pozisyonu
* | (θ~x,n~, θ~x,n~, θ~x,n~)| double
rPostheta[3] |  n. ‘inci 3D Taramanın Rotasyonu
|====================

=== 3.2. Kodun İncelenmesi

Projenin main fonksiyonu *src/slam6d* dizinindeki *slam6D.cc* dosyasının içerisinde yer almaktadır.

Kaynak code klasör yolu:

image::kaynakcode.PNG[indoor,480,160,align="center"]

==== Dönüşüm ve Çevrimin Hesaplanması

image::k1.png[indoor,480,160,align="center"]

image::k2.png[indoor,320,160,align="center"]


Bu formüllerin kullanıldığı code dosyasının yolu:


image::formul4.png[indoor,240,180,align="center"]

image::formula5.png[indoor,240,180,align="center"]

image::k3.png[indoor,240,180,align="center"]

(icp6Dsvd.cc)

[source, C++]
----

Matrix U(3,3);
  DiagonalMatrix Lamda(3);
  Matrix V(3,3);
  // Make SVD
  SVD(H, Lamda, U, V);

  // Get rotation
  R = V*(U.t());

----

image::k4.png[indoor,240,160,align="center"]

[source, C++]
----

// calculate the rotation matrix
  double m[3][3]; // rot matrix
  quaternion2matrix(q, m);

  M4identity(alignfx);

  alignfx[0] = m[0][0];
  alignfx[1] = m[1][0];
  alignfx[2] = m[2][0];
  alignfx[3] = 0.0;
  alignfx[4] = m[0][1];
  alignfx[5] = m[1][1];
  alignfx[6] = m[2][1];
  alignfx[7] = 0.0;
  alignfx[8] = m[0][2];
  alignfx[9] = m[1][2];
  alignfx[10] = m[2][2];
  alignfx[11] = 0.0;

  // calculate the translation vector,
  alignfx[12] = cm[0] - m[0][0]*cd[0] - m[0][1]*cd[1] - m[0][2]*cd[2];
  alignfx[13] = cm[1] - m[1][0]*cd[0] - m[1][1]*cd[1] - m[1][2]*cd[2];
  alignfx[14] = cm[2] - m[2][0]*cd[0] - m[2][1]*cd[1] - m[2][2]*cd[2];

----

==== ICP tabanlı 6D Slam 


image::k5.png[indoor,480,240,align="center"]

(elch6Deuler.cc)

[source, C++]
----

double delta[6];
  delta[0] = allScans[last]->get_rPos()[0];
  delta[1] = allScans[last]->get_rPos()[1];
  delta[2] = allScans[last]->get_rPos()[2];
  delta[3] = allScans[last]->get_rPosTheta()[0];
  delta[4] = allScans[last]->get_rPosTheta()[1];
  delta[5] = allScans[last]->get_rPosTheta()[2];

  my_icp6D->match(start, end);

  delete start;
  delete end;
  
  delta[0] = allScans[last]->get_rPos()[0] - delta[0];
  delta[1] = allScans[last]->get_rPos()[1] - delta[1];
  delta[2] = allScans[last]->get_rPos()[2] - delta[2];
  delta[3] = allScans[last]->get_rPosTheta()[0] - delta[3];
  delta[4] = allScans[last]->get_rPosTheta()[1] - delta[4];
  delta[5] = allScans[last]->get_rPosTheta()[2] - delta[5];

  if(!quiet) {
    cout << "Delta: " << delta[0] << " " << delta[1] << " " << delta[2]
         << " " << delta[3] << " " << delta[4] << " " << delta[5] << endl;
  }

  double rPos[3], rPosTheta[3];
  for(int i = 1; i < n; i++) {
    rPos[0] = allScans[i]->get_rPos()[0] +
      delta[0] * (weights[0][i] - weights[0][0]);
    rPos[1] = allScans[i]->get_rPos()[1] +
      delta[1] * (weights[1][i] - weights[1][0]);
    rPos[2] = allScans[i]->get_rPos()[2] +
      delta[2] * (weights[2][i] - weights[2][0]);
    rPosTheta[0] = allScans[i]->get_rPosTheta()[0] +
      delta[3] * (weights[3][i] - weights[3][0]);
    rPosTheta[1] = allScans[i]->get_rPosTheta()[1] +
      delta[4] * (weights[4][i] - weights[4][0]);
    rPosTheta[2] = allScans[i]->get_rPosTheta()[2] +
      delta[5] * (weights[5][i] - weights[5][0]);

    allScans[i]->transformToEuler(rPos, rPosTheta,
                                  Scan::ELCH, i == n-1 ? 2 : 1);
  }

----

